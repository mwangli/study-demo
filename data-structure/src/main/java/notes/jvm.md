##### 类装载子系统

1. 加载：通过类的全限定名获取字节码文件，以二进制流的方式加载字节码文件，在内存中生成一个Class对象。
2. 链接：
    - 验证：验证当前字节码文件是否符合虚拟机规范，包含文件格式验证、元数据验证、字节码验证、符号引用验证。
    - 准备：为类变量分配内存并设置默认初始值，final修饰的变量在编译时分配，实例变量在堆上分配。
    - 解析：将常量池内符号引用转换为直接引用。
3. 初始化：执行类的构造器方法clinit()，按顺序执行类变量的赋值操作和静态代码块中的内容。

##### 类加载器

1. 引导类加载器：使用C/C++语言实现，用于加载包名为java、javax、sun等开头的核心类
2. 扩展类加载器：间接继承自ClassLoader，用于加载jre/lib/ext目录下的类
3. 系统类加载器：间接继承自ClassLoader，用于加载用户自己编写的类

##### 双亲委派机制

- 原理：当一个类加载器收到了类加载请求，他自己不会先去加载，而是把这个请求委托给父加载器去加载，依次向上委托直至引导类加载器；当父加载器可以完成加载时直接返回成功，当父加载器无法完成加载任务时，子加载器才会尝试自己加载
- 优势：避免类的重复加载；防止核心API被篡改。

> 判断两个Class对象为同一个类的条件：

1. 类的全限定名(包括包名)必须一致
2. 加载类的ClassLoader实例对象必须相同

##### 运行时数据区

![运行时数据区](images/运行时数据区.png)

1. 程序计数器：存储即将执行的下一条指令的地址，保证程序在进行线程切换后能顺利地往下执行
2. 虚拟机栈：每个线程都会创建一个虚拟机栈，其中包含多个栈帧，每个栈帧对应着一次方法调用，方法调用时入栈，方法执行完出栈
3. 本地方法栈：线程私有，保存着本地方法的调用栈帧
4. 堆空间
    - 新生代：
        - Eden
        - s0
        - s1
    - 老年代：
5. 方法区

##### 栈帧

1. 局部变量表：以数字形式存储方法参数和定义在方法体内的局部变量，基本单位为Slot(变量槽)， 32位类型占一个基本单位，64位类型(long,double)占两个，实例方法第一个变量槽存放的是this对象
   当局部变量超过其作用域，之后声明的变量可以复用槽以节省资源
2. 操作数栈：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据 用于保存计算过程的中间结果，作为计算过程中变量的临时存储空间，32位类型占一个栈单位深度，64位占两个。
3. 动态链接：指向运行时常量池中该帧所属方法的引用，将符号引用转换为调用方法的直接引用
4. 方法返回地址：存放调用该方法的程序计数器的值，在方法调用完成后回到被调用的位置。

##### 执行引擎

1. 解释器：逐行解释执行，快速响应，保证执行效率
2. 即时编译器：将热点代码翻译成机器执行并缓存，保证执行性能
3. 垃圾回收器

##### StringTable

1. 字符串存储格式

##### 垃圾回收

1. 标记阶段
    - 引用计数
    - 根可达分析
2. 清除阶段
    - 复制整理压缩
    - 复制清除